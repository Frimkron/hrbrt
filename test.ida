[!] I should be testing behaviour regardless of implementation. 
- utility methods like ZeroOrMore are an implementation concern
[?] What is the desired behaviour of Document?
- Should invoke parsing of the other appropriate symbols.
- Should only consume input on success
[!] Correct working of the parse method is inherently linked to the 
	implementation of Input. But Input has its own tests - this would 
	result in test overlap.
[*] Mock out the Input class? 
- the implementation would have to recreate *all* of the behaviour of 
	Input for it to work properly. 
- It need only recreate the *necessary* behaviour. And while this may
	come close to the full implementation, it is free from the 
	implementation iteself in that the true implementation may become
	more sophisticated later on

So. We pass in a branchable, commitable mock input, and check that in 
addition to the appropriate symbols being invoked with the correct 
cardinality, the method leaves the mock input at the correct position.

---

[!] Text blocks, choice blocks and instruction blocks can be broken by
	blank lines and feedback.
- Of these, choice blocks are the biggest issue because it changes the
  flow of the document.
[?] Aren't blank lines used to deliberately split up blocks?
- I think the issue was that the recipient can add blank lines
- But the recipient can do lots of things like that. They could completely
  destroy the document, potentially.
- The syntax aims to prevent *accidental* destruction as much as possible
- Feedback certainly shouldn't break up a block.
[!] A recipient might *replace* a blank line with feedback, thereby turning
	separated blocks into a single block and changing the document
	
	: This is a single block               : This is a single block
	: of text                              : of text
	                                ->     great jorb
	: And this is another single           : And this is another single
	: block of text                        : block of text

    : [] block 1 choice A                  : [] block 1 choice A
    : [] block 1 choice B                  : [] block 1 choice B
                                           derp
    : [] block 2 choice A                  : [] block 2 choice A
    : [] block 2 choice B                  : [] block 2 choice B

[*] Maybe some kind of separator line - one which is unobtrusive yet doesnt
	invite the recipient to write on it

	: This is a single block               : This is a single block
	: of text                              : of text
	: - - - - -                            : - - - - - 
	                                ->     great jorb
	: And this is another single           : And this is another single
	: block of text                        : block of text

    : [] block 1 choice A                  : [] block 1 choice A
    : [] block 1 choice B                  : [] block 1 choice B
    : - - - - -                            : - - - - -
                                           derp
    : [] block 2 choice A                  : [] block 2 choice A
    : [] block 2 choice B                  : [] block 2 choice B

[*] Maybe choice blocks MUST be separated by text or instruction blocks.
	After all, the following is kind of ambiguous:
	
	: [] Option A
	:		-- is great
	: [] Option B
	
	: [] Option C
	: [] Option D
	
[!] Sender may want a specific break in a text block - i.e. to split 
	into distinct paragraphs
[?] Is this that much of an issue? What effect would it have if the 
	recipient inadvertantly combined paragraphs in the response?
[!] Another potential issue is that the author might be confused that 
	text and instruction blocks are separated by blank lines, but 
	choice blocks aren't.
[!] The recipient, too, may be confused by separated choice blocks - 
	it would no longer be obvious which choices are together
[*] So disallow blank lines in the middle of choices - simple

	:	This is text block 1
	:	it continues on this line
	lol wut
	:	This is a separate text block which 
	:	would be its own paragraph, but recipient
	:	has combined them by writing in the blank
	:	line
	
	:	[] This is a choice block
	
	:	[] This choice block is illegal becausee they *must*
	:		be separated by other blocks
	lol wut
	:	[] This block is allowed because the feedback makes
	:		it part of the block above
	
[!] Recipient could add blank lines and break document structure

[*] Another option is to have specific syntax for the start of a block
	e.g:
	
	::	Start of text block is here
	: 	and continues onto further lines
	
	%%	Start of instruction block is here
	%	and continues onto further lines
	
	%	The blank lines above does not break 
	%	the block, because we know explicitly
	% 	when a new one is started
	
	::	[] Start of choice block is here
	:	[] and continues onto further lines
	
	:	[] Blank lines above does not break
	:	[] The choice block. But is that confusing?

[*] But maybe a text block *should* be separated when the user inserts
	feedback in the middle of it - after all, we want feedback to be 
	associated with the right part of the document
[?] Do we? This is something of a feature creep - how would a command
	line based reader allow for user feedback between paragraphs?
	It's always been assumed that feedback would be like a "comments"
	section associated with whole choice blocks or even whole sections.

- Possible syntax ideas:

	. A text block
	: with explicit
	: start marker.
	: Can you spot it?
	
	, An instruction block
	; with explicit start
	; marker. Found it?
	
	. [] A choice block
	: [] With explicit start
	: [] Blank lines still are
	: [] Not allowed inbetween
	
[?] Too easy for author to forget the opening syntax and/or make typos?

	:: A text block
	:  which goes on
	:  Not allowed consecutive 
	:  opening markers
	
	;; An instruction block
	;  which goes on
	
	:: [] Option A
	:  [] Option B
	
	----
	
	`` A text block
	`  which goes on
	
	----
	
	|| Pipes are another 
	|  option. But do they
	|  look too much like Ls
	|  or 1s?
	
	|: Start of block
	|  continuation
	
	+: Instruction
	+  block
	+  goes here
	
	%: Instruction
	%  block is here
	%: The colon is 
	%  kinda nice.
	
	:: Text block
	:  blah blah
	
	%% Are double percents
	%  really all that bad?
	
	|: [] Hello
	|  [] Goodbye
	|  [] Pipe colon looks like a smiley
	
	
[?] Why not allow consequtive opening markers?
- Because it would confuse recipient in the case of choice blocks
[*] Choice blocks have to be separated by other blocks anyway
[!] Backticks are ugly and confusing

[!] Opening block syntax still doesn't solve issue of blank lines between
	choice lines. Either author is allowed to confuse recipient, or 
	recipient is allowed to break document structure.
[?] Is it really all that confusing to have separated choice lines?
	Typically the author has to ask a question with a text block for 
	a set of choice lines to make sense

	::	Yo what's up?
	
	::	[] Not a lot
	:	[] Lots of stuff
	
	
	:	[] Cats
	:	[] Dogs
	
[*] Ultimately, if the author creates a document which the recipient
	gets confused by and doesn't complete in the way they hoped, there's
	not a lot that can be done
	- There will always be ways for the recipient to mess up
	- The method that lessens the chance of the recipient destroying 
		the syntax should be the priority.
	- Having them mark 2 answers in a set, or leave a set out, isn't
		that major and could happen anyway, if they wrongly assume
		they can tick all that apply.
[*] So, choice blocks continue, ignoring feedback and blank lines,  
	until the next block opening. And consecutive choice blocks are 
	not allowed at all.

[!] Can't have choice response on its own line because description part
	is expected at start of line. 
[*] Allow optional description newlines before and after separator

	: [] Option A
	VALID!
	~~~~~~~~~~~~~
	: [] Option A -- is great
	VALID!
	~~~~~~~~~~~~~
	: [] Option A --
	:		is great
	VALID!
	~~~~~~~~~~~~~
	: [] Option A
	:		-- is great
	VALID
	~~~~~~~~~~~~~
	: [] Option A
	
	:		-- is great
	NOT VALID
	~~~~~~~~~~~~~
	: [] Option A --
	
	: is great
	NOT VALID
	~~~~~~~~~~~~~
	: [] Option A
	:
	: -- is great
	NOT VALID
	~~~~~~~~~~~~~
	: [] Option A --
	:
	: is great
	NOT VALID
	~~~~~~~~~~~~~
	: [] Option A
	:--
	: is great
	VALID!
	
<Choice> ::= <QuoteMarker>? <TextLineMarker> <LineWhitespace>? <ChoiceMarker> <ChoiceDescription> <ChoiceResponse>?
<ChoiceResponse> ::= <ChoiceDescNewline>? <ChoiceResponseSeparator> <ChoiceDescNewline>? <ChoiceResponseDesc>? <ChoiceResponseGoto>?


QM TLM LW CM CDP CDN CRS CRDP N

QM TLM LW CM CDR CRS CDN CRDP N

P (N P)* ( N? S N? P (N P)* )?

[*] Make ChoiceDescNewline a reused symbol.

[?] Implications of making FirstTextLineMarker and TextLineMarker distinct by
	nature of their definitions - i.e. using a not on second character
- This would only be an issue where we prematurely disregard a line based on
  its start marker
- A FirstTextLineMarker could be disregarded because TextLineMarker disallows 
  it, even though the line itself isn't a valid FirstTextLine.
[?] Is this a problem?
- Could be a blank line. But a blank line wouldn't be a valid TextLine either.
[?] What about with choices, then?
- Could disregard a FirstChoice. Obviously this is fine as it isn't a TextLine
- Wouldn't disregard a Choice. But a choice block has to begin with a 
  FirstTextLineMarker anyway.
[!] So Choices get absorbed into TextBlocks if ChoiceBlock not started properly.
    Might be nicer for user if Choice line was recognised and ValidationError
    thrown
[!] But on the other hand, this removes flexibility. User isn't permitted to
	write a TextLine that looks like a Choice line.
- But they can't write a FirstTextLine that looks like a FirstChoiceLine at all
  because that's the syntax. 
[*] I think its best to not try to be clever to make the syntax friendlier.
    I'll stick to the rule of thumb that the more rules are involved, the 
    less friendly it becomes
[!] By this logic, I should allow TextLines and InstructionLines to be 
	absorbed into feedback by removing 'nots' from them, because they 
	shouldn't exist without block starts
[?] Should non-absorbing rules be part of the FeedbackLine definition or should 
	the relevant section/block definitions? 
- Feedback lines will always preceed the start of other blocks and sections
- Therefore the check for Headings, FirstTextLines, FirstInstructionLines and
  FirstChoices *could* be moved into FeedbackLine. 
- This presumes where FeedbackLine will be used
- But as a result it reduces duplication in the logic which must be used around
  the use of FeedbackLine for it to operaate as expected
[*] I'd rather go with the (minor) duplication. It feels less magic.


[?] How does the logic for this choice-walking work?

  S ----> A <---> D --.
  |       ^       ^   |
  |       |  .----'   |
  v       v /         |
  B ----> C ----> E <-'


S: A,B
A: D,C
B: C
C: A,D,E
D: A
E 
                    .-> S
            .-> A --|   ^----.
    .-> D --|       '-> C -> B
E --|       '-----------^
    '-------------------' 

S
|-- A
    |-- D (valid)
    |   |-- A (ongoing)
    |   '-- E (valid)
    '-- C (valid)
        |-- D (valid)
        |   |-- A (ongoing)
        |   '-- E (valid)
        '-- E (valid)

- Ongoing loops are considered valid
- When is a section not ongoing?
- If a section consists *only* of choices which loop, *then* it is 
  invalid
[!] Nope - a section could *only* loop back to a section which then
    leads to the end.
- For goodness sake - a human could try all paths without issue, 
  couldn't they?
- A loop means it returns to a previous state
- Choices either loop back, reach the end, or are invalid
- We immediately stop for an invalid path - others either loop or reach
  the end
- Looping back is ok provided there is a valid path from this state
- But that valid path might be after further loop backs.
- A section is ok if each choice is either valid or loops back to 
  a valid section
- But there needs to be a further invalidity check.
- At top of dependency chain there must be a valid path
- Must be a valid path to satisfy dependency chain.
- Dependencies will be sections currently on the stack
- Are dependency loops possible?

 .------.  
 v      |  
 A ---> B
 |
 v
 E

A
|-- B (valid if A valid)
|   '-- A (unknown)
'-- E (valid)

.---------.
|         v
|  A ---> B -.
|  ^      |  |
|  |      v  |
'- D <--- C  |
   ^         |        
   '---------'

A
'-- B
    |-- C
    |   '-- D
    |       |-- A (dep)
    |       '-- B (dep)
    '-- D        
        |-- A (dep)
        '-- B (dep)

.---------.
|         v
|  A ---> B --.   E
|  ^      |   |   ^
|  |      v   |   |
'- D <--- C <-^-- S
   ^          |        
   '----------'

S (if E and C)
|-- E (valid)
'-- C (if D)
    '-- D (if B and A)
        |-- B (if C and D)
        |   |-- C (?)
        |   '-- D (?)
        '-- A (if B)
            '-- B (if C and D)
                |-- C (?)
                '-- D (?)

- Every choice is a dependency, looped or not
- Dependencies are chained
- They are depending on that section having an end-reaching choice
- A section is valid IF each of its choices are valid
- A section's validity *depends* on *all* its choices being valid

  S ---> A ---> E
  ^      |
  '------'

A if S and E

S
'-- A
    |-- E (valid)
    '-- S (?)
    
S depends on A which depends on S
[?] Is a section valid if it consists of loops and at least one valid
    choice?
    
  S ---> A --.
  |      ^   |
  v      '---'
  E

S (invalid)
|-- A (invalid)
|   '-- A (invalid)
'-- E

- A loop is invalid if it's to a section having it's final choice
  tested
  
                .------.
                v      |
  S ---> A ---> B ---> C
  |      ^      |
  v      '------'
  E

S (invalid)
|-- A (invalid)
|   '-- B (invalid)
|       |-- C 
|       |   '-- B (? choices remain)
|       '-- A (final choice - invalid)

  .------.      .------.
  v      |      v      |
  S ---> A ---> B ---> C
  |      ^      |
  v      '------'
  E

S
|-- A
|   |-- S (? choices remain)
|   '-- B
|       |-- C 
|       |   '-- B (? choices remain)
|       '-- A (final choice - invalid)

[!] That ain't right.
[*] There'a subtlety to consider. A section can depend on another 
    section which in turn depends on another section. This chaining
    of looped dependencies should be respected
[*] There's a difference between testing last choice and the last 
    chance to prove a section valid.
[*] Last choice is only last chance if we are not waiting on another
    dependency
    
  .------.      .------.
  v      |      v      |
  S ---> A ---> B ---> C
  |    / ^      |
  v   |  '------'
  E   |
      |      .------.
      v      v      |
      F ---> G ---> H <-.
      ^      |      '---'
      '------'

S 
|-- A   
|   |-- S (?)
|   |-- B 
|   |   |-- C 
|   |   |   | last chance   
|   |   |   '-- B (?)
|   |   | last chance
|   |   '-- A (?)
|   '-- F
|       | last chance
|       '-- G
|           |-- F (?)
|           | last chance   <-- we have dependency on F, but it's F's
|           |                   last chance. Therefore last chance
|           '-- H
|               |-- H (?)
|               | last chance <-- dep on H, but H's last chance
|               '-- G (lc, invalid!)

[*] it's a section's last chance if no valid choice has yet been found 
    and it has no other choices and no dependencies that aren't on their 
    last chance

  .------.      .------.
  v      |      v      |
  S ---> A ---> B ---> C
  |    / ^      |
  v   |  '------'
  E   |
  ^   |      .------.
  |   v      v      |
  '-- F ---> G ---> H <-.
      ^      |      '---'
      '------'

S
|-- A
|   |-- S (?)
|   |-- B
|   |   |-- C
|   |   |   '-- B (?)
|   |   |lc
|   |   '-- A (?)
|   '-- F
|       |-- G
|       |   |-- F (?)
|       |   '-- H
|       |       |-- H (?)
|       |       '-- G (?)
|       |lc
|       '-- E (valid)
|lc
'-- E (valid)

 S ---> A ---> E
 ^      |
 '------'

S
|lc
'-- A
    |-- E (valid)
    '-- S (?)
    
 S ---> A --.
 |      ^   |
 v      '---'
 E

S
|-- A
|   |lc
|   '-- A (?) invalid

[*] In addition to "walked" set, we need a "last-chance" set too.
- This would be checked when a loop is encountered, and if in the 
  last chance set, an error is raised 
[!] No, that's not right.
- A dependency simply isn't a potential lead if its in the last chance
  set.
