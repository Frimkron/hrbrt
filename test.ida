[!] I should be testing behaviour regardless of implementation. 
- utility methods like ZeroOrMore are an implementation concern
[?] What is the desired behaviour of Document?
- Should invoke parsing of the other appropriate symbols.
- Should only consume input on success
[!] Correct working of the parse method is inherently linked to the 
	implementation of Input. But Input has its own tests - this would 
	result in test overlap.
[*] Mock out the Input class? 
- the implementation would have to recreate *all* of the behaviour of 
	Input for it to work properly. 
- It need only recreate the *necessary* behaviour. And while this may
	come close to the full implementation, it is free from the 
	implementation iteself in that the true implementation may become
	more sophisticated later on

So. We pass in a branchable, commitable mock input, and check that in 
addition to the appropriate symbols being invoked with the correct 
cardinality, the method leaves the mock input at the correct position.

---

[!] Text blocks, choice blocks and instruction blocks can be broken by
	blank lines and feedback.
- Of these, choice blocks are the biggest issue because it changes the
  flow of the document.
[?] Aren't blank lines used to deliberately split up blocks?
- I think the issue was that the recipient can add blank lines
- But the recipient can do lots of things like that. They could completely
  destroy the document, potentially.
- The syntax aims to prevent *accidental* destruction as much as possible
- Feedback certainly shouldn't break up a block.
[!] A recipient might *replace* a blank line with feedback, thereby turning
	separated blocks into a single block and changing the document
	
	: This is a single block               : This is a single block
	: of text                              : of text
	                                ->     great jorb
	: And this is another single           : And this is another single
	: block of text                        : block of text

    : [] block 1 choice A                  : [] block 1 choice A
    : [] block 1 choice B                  : [] block 1 choice B
                                           derp
    : [] block 2 choice A                  : [] block 2 choice A
    : [] block 2 choice B                  : [] block 2 choice B

[*] Maybe some kind of separator line - one which is unobtrusive yet doesnt
	invite the recipient to write on it

	: This is a single block               : This is a single block
	: of text                              : of text
	: - - - - -                            : - - - - - 
	                                ->     great jorb
	: And this is another single           : And this is another single
	: block of text                        : block of text

    : [] block 1 choice A                  : [] block 1 choice A
    : [] block 1 choice B                  : [] block 1 choice B
    : - - - - -                            : - - - - -
                                           derp
    : [] block 2 choice A                  : [] block 2 choice A
    : [] block 2 choice B                  : [] block 2 choice B

[*] Maybe choice blocks MUST be separated by text or instruction blocks.
	After all, the following is kind of ambiguous:
	
	: [] Option A
	:		-- is great
	: [] Option B
	
	: [] Option C
	: [] Option D
	
[!] Sender may want a specific break in a text block - i.e. to split 
	into distinct paragraphs
[?] Is this that much of an issue? What effect would it have if the 
	recipient inadvertantly combined paragraphs in the response?
[!] Another potential issue is that the author might be confused that 
	text and instruction blocks are separated by blank lines, but 
	choice blocks aren't.
[!] The recipient, too, may be confused by separated choice blocks - 
	it would no longer be obvious which choices are together
[*] So disallow blank lines in the middle of choices - simple

	:	This is text block 1
	:	it continues on this line
	lol wut
	:	This is a separate text block which 
	:	would be its own paragraph, but recipient
	:	has combined them by writing in the blank
	:	line
	
	:	[] This is a choice block
	
	:	[] This choice block is illegal becausee they *must*
	:		be separated by other blocks
	lol wut
	:	[] This block is allowed because the feedback makes
	:		it part of the block above
	
[!] Recipient could add blank lines and break document structure

[*] Another option is to have specific syntax for the start of a block
	e.g:
	
	::	Start of text block is here
	: 	and continues onto further lines
	
	%%	Start of instruction block is here
	%	and continues onto further lines
	
	%	The blank lines above does not break 
	%	the block, because we know explicitly
	% 	when a new one is started
	
	::	[] Start of choice block is here
	:	[] and continues onto further lines
	
	:	[] Blank lines above does not break
	:	[] The choice block. But is that confusing?

[*] But maybe a text block *should* be separated when the user inserts
	feedback in the middle of it - after all, we want feedback to be 
	associated with the right part of the document
[?] Do we? This is something of a feature creep - how would a command
	line based reader allow for user feedback between paragraphs?
	It's always been assumed that feedback would be like a "comments"
	section associated with whole choice blocks or even whole sections.

- Possible syntax ideas:

	. A text block
	: with explicit
	: start marker.
	: Can you spot it?
	
	, An instruction block
	; with explicit start
	; marker. Found it?
	
	. [] A choice block
	: [] With explicit start
	: [] Blank lines still are
	: [] Not allowed inbetween
	
[?] Too easy for author to forget the opening syntax and/or make typos?

	:: A text block
	:  which goes on
	:  Not allowed consecutive 
	:  opening markers
	
	;; An instruction block
	;  which goes on
	
	:: [] Option A
	:  [] Option B
	
	----
	
	`` A text block
	`  which goes on
	
	----
	
	|| Pipes are another 
	|  option. But do they
	|  look too much like Ls
	|  or 1s?
	
	|: Start of block
	|  continuation
	
	+: Instruction
	+  block
	+  goes here
	
	%: Instruction
	%  block is here
	%: The colon is 
	%  kinda nice.
	
	:: Text block
	:  blah blah
	
	%% Are double percents
	%  really all that bad?
	
	|: [] Hello
	|  [] Goodbye
	|  [] Pipe colon looks like a smiley
	
	
[?] Why not allow consequtive opening markers?
- Because it would confuse recipient in the case of choice blocks
[*] Choice blocks have to be separated by other blocks anyway
[!] Backticks are ugly and confusing

[!] Opening block syntax still doesn't solve issue of blank lines between
	choice lines. Either author is allowed to confuse recipient, or 
	recipient is allowed to break document structure.
[?] Is it really all that confusing to have separated choice lines?
	Typically the author has to ask a question with a text block for 
	a set of choice lines to make sense

	::	Yo what's up?
	
	::	[] Not a lot
	:	[] Lots of stuff
	
	
	:	[] Cats
	:	[] Dogs
	
[*] Ultimately, if the author creates a document which the recipient
	gets confused by and doesn't complete in the way they hoped, there's
	not a lot that can be done
	- There will always be ways for the recipient to mess up
	- The method that lessens the chance of the recipient destroying 
		the syntax should be the priority.
	- Having them mark 2 answers in a set, or leave a set out, isn't
		that major and could happen anyway, if they wrongly assume
		they can tick all that apply.
[*] So, choice blocks continue, ignoring feedback and blank lines,  
	until the next block opening. And consecutive choice blocks are 
	not allowed at all.

[!] Can't have choice response on its own line because description part
	is expected at start of line. 
[*] Allow optional description newlines before and after separator

	: [] Option A
	VALID!
	~~~~~~~~~~~~~
	: [] Option A -- is great
	VALID!
	~~~~~~~~~~~~~
	: [] Option A --
	:		is great
	VALID!
	~~~~~~~~~~~~~
	: [] Option A
	:		-- is great
	VALID
	~~~~~~~~~~~~~
	: [] Option A
	
	:		-- is great
	NOT VALID
	~~~~~~~~~~~~~
	: [] Option A --
	
	: is great
	NOT VALID
	~~~~~~~~~~~~~
	: [] Option A
	:
	: -- is great
	NOT VALID
	~~~~~~~~~~~~~
	: [] Option A --
	:
	: is great
	NOT VALID
	~~~~~~~~~~~~~
	: [] Option A
	:--
	: is great
	VALID!
	
<Choice> ::= <QuoteMarker>? <TextLineMarker> <LineWhitespace>? <ChoiceMarker> <ChoiceDescription> <ChoiceResponse>?
<ChoiceResponse> ::= <ChoiceDescNewline>? <ChoiceResponseSeparator> <ChoiceDescNewline>? <ChoiceResponseDesc>? <ChoiceResponseGoto>?


QM TLM LW CM CDP CDN CRS CRDP N

QM TLM LW CM CDR CRS CDN CRDP N

P (N P)* ( N? S N? P (N P)* )?

[*] Make ChoiceDescNewline a reused symbol.

[?] Implications of making FirstTextLineMarker and TextLineMarker distinct by
	nature of their definitions - i.e. using a not on second character
- This would only be an issue where we prematurely disregard a line based on
  its start marker
- A FirstTextLineMarker could be disregarded because TextLineMarker disallows 
  it, even though the line itself isn't a valid FirstTextLine.
[?] Is this a problem?
- Could be a blank line. But a blank line wouldn't be a valid TextLine either.
[?] What about with choices, then?
- Could disregard a FirstChoice. Obviously this is fine as it isn't a TextLine
- Wouldn't disregard a Choice. But a choice block has to begin with a 
  FirstTextLineMarker anyway.
[!] So Choices get absorbed into TextBlocks if ChoiceBlock not started properly.
    Might be nicer for user if Choice line was recognised and ValidationError
    thrown
[!] But on the other hand, this removes flexibility. User isn't permitted to
	write a TextLine that looks like a Choice line.
- But they can't write a FirstTextLine that looks like a FirstChoiceLine at all
  because that's the syntax. 
[*] I think its best to not try to be clever to make the syntax friendlier.
    I'll stick to the rule of thumb that the more rules are involved, the 
    less friendly it becomes
[!] By this logic, I should allow TextLines and InstructionLines to be 
	absorbed into feedback by removing 'nots' from them, because they 
	shouldn't exist without block starts
[?] Should non-absorbing rules be part of the FeedbackLine definition or should 
	the relevant section/block definitions? 
- Feedback lines will always preceed the start of other blocks and sections
- Therefore the check for Headings, FirstTextLines, FirstInstructionLines and
  FirstChoices *could* be moved into FeedbackLine. 
- This presumes where FeedbackLine will be used
- But as a result it reduces duplication in the logic which must be used around
  the use of FeedbackLine for it to operaate as expected
[*] I'd rather go with the (minor) duplication. It feels less magic.


[?] How does the logic for this choice-walking work?

  S ----> A <---> D --.
  |       ^       ^   |
  |       |  .----'   |
  v       v /         |
  B ----> C ----> E <-'


S: A,B
A: D,C
B: C
C: A,D,E
D: A
E 
                    .-> S
            .-> A --|   ^----.
    .-> D --|       '-> C -> B
E --|       '-----------^
    '-------------------' 

S
|-- A
    |-- D (valid)
    |   |-- A (ongoing)
    |   '-- E (valid)
    '-- C (valid)
        |-- D (valid)
        |   |-- A (ongoing)
        |   '-- E (valid)
        '-- E (valid)

- Ongoing loops are considered valid
- When is a section not ongoing?
- If a section consists *only* of choices which loop, *then* it is 
  invalid
[!] Nope - a section could *only* loop back to a section which then
    leads to the end.
- For goodness sake - a human could try all paths without issue, 
  couldn't they?
- A loop means it returns to a previous state
- Choices either loop back, reach the end, or are invalid
- We immediately stop for an invalid path - others either loop or reach
  the end
- Looping back is ok provided there is a valid path from this state
- But that valid path might be after further loop backs.
- A section is ok if each choice is either valid or loops back to 
  a valid section
- But there needs to be a further invalidity check.
- At top of dependency chain there must be a valid path
- Must be a valid path to satisfy dependency chain.
- Dependencies will be sections currently on the stack
- Are dependency loops possible?

 .------.  
 v      |  
 A ---> B
 |
 v
 E

A
|-- B (valid if A valid)
|   '-- A (unknown)
'-- E (valid)

.---------.
|         v
|  A ---> B -.
|  ^      |  |
|  |      v  |
'- D <--- C  |
   ^         |        
   '---------'

A
'-- B
    |-- C
    |   '-- D
    |       |-- A (dep)
    |       '-- B (dep)
    '-- D        
        |-- A (dep)
        '-- B (dep)

.---------.
|         v
|  A ---> B --.   E
|  ^      |   |   ^
|  |      v   |   |
'- D <--- C <-^-- S
   ^          |        
   '----------'

S (if E and C)
|-- E (valid)
'-- C (if D)
    '-- D (if B and A)
        |-- B (if C and D)
        |   |-- C (?)
        |   '-- D (?)
        '-- A (if B)
            '-- B (if C and D)
                |-- C (?)
                '-- D (?)

- Every choice is a dependency, looped or not
- Dependencies are chained
- They are depending on that section having an end-reaching choice
- A section is valid IF each of its choices are valid
- A section's validity *depends* on *all* its choices being valid

  S ---> A ---> E
  ^      |
  '------'

A if S and E

S
'-- A
    |-- E (valid)
    '-- S (?)
    
S depends on A which depends on S
[?] Is a section valid if it consists of loops and at least one valid
    choice?
    
  S ---> A --.
  |      ^   |
  v      '---'
  E

S (invalid)
|-- A (invalid)
|   '-- A (invalid)
'-- E

- A loop is invalid if it's to a section having it's final choice
  tested
  
                .------.
                v      |
  S ---> A ---> B ---> C
  |      ^      |
  v      '------'
  E

S (invalid)
|-- A (invalid)
|   '-- B (invalid)
|       |-- C 
|       |   '-- B (? choices remain)
|       '-- A (final choice - invalid)

  .------.      .------.
  v      |      v      |
  S ---> A ---> B ---> C
  |      ^      |
  v      '------'
  E

S
|-- A
|   |-- S (? choices remain)
|   '-- B
|       |-- C 
|       |   '-- B (? choices remain)
|       '-- A (final choice - invalid)

[!] That ain't right.
[*] There'a subtlety to consider. A section can depend on another 
    section which in turn depends on another section. This chaining
    of looped dependencies should be respected
[*] There's a difference between testing last choice and the last 
    chance to prove a section valid.
[*] Last choice is only last chance if we are not waiting on another
    dependency
    
  .------.      .------.
  v      |      v      |
  S ---> A ---> B ---> C
  |    / ^      |
  v   |  '------'
  E   |
      |      .------.
      v      v      |
      F ---> G ---> H <-.
      ^      |      '---'
      '------'

S 
|-- A   
|   |-- S (?)
|   |-- B 
|   |   |-- C 
|   |   |   | last chance   
|   |   |   '-- B (?)
|   |   | last chance
|   |   '-- A (?)
|   '-- F
|       | last chance
|       '-- G
|           |-- F (?)
|           | last chance   <-- we have dependency on F, but it's F's
|           |                   last chance. Therefore last chance
|           '-- H
|               |-- H (?)
|               | last chance <-- dep on H, but H's last chance
|               '-- G (lc, invalid!)

[*] it's a section's last chance if no valid choice has yet been found 
    and it has no other choices and no dependencies that aren't on their 
    last chance

  .------.      .------.
  v      |      v      |
  S ---> A ---> B ---> C
  |    / ^      |
  v   |  '------'
  E   |
  ^   |      .------.
  |   v      v      |
  '-- F ---> G ---> H <-.
      ^      |      '---'
      '------'

S
|-- A
|   |-- S (?)
|   |-- B
|   |   |-- C
|   |   |   '-- B (?)
|   |   |lc
|   |   '-- A (?)
|   '-- F
|       |-- G
|       |   |-- F (?)
|       |   '-- H
|       |       |-- H (?)
|       |       '-- G (?)
|       |lc
|       '-- E (valid)
|lc
'-- E (valid)

 S ---> A ---> E
 ^      |
 '------'

S
|lc
'-- A
    |-- E (valid)
    '-- S (?)
    
 S ---> A --.
 |      ^   |
 v      '---'
 E

S
|-- A
|   |lc
|   '-- A (?) invalid

[*] In addition to "walked" set, we need a "last-chance" set too.
- This would be checked when a loop is encountered, and if in the 
  last chance set, an error is raised 
[!] No, that's not right.
- A dependency simply isn't a potential lead if its in the last chance
  set.

------

[?] How should running work for complete/incomplete files?
- Runs if run type specified, or no output file specified
[?] Why - what's the significance of that default behaviour?
- I think the intention was to provide a sensible default if the user 
  specifies only an input file, i.e. dectree myfile.dt
[*] Maybe the default behaviour should only be invoked if *no* options
	are specified at all.
	
[!] Input/process/output is getting confused. There are multiple use
	cases which are being mashed into each other
- Use case: convert a questionaire to open document format (rare)
- Use case: run and fill in a dectree file (likely)
- Use case: summarise a completed dectree file (likely)

[?] Does the format parameter govern how a fresh questionaire should be 
	output, or how a completed questionaire should be summarized?
- I guess there needs to be another option. 
- It can be inferred that a completed document should be summarised
[!] But this may not be the user's intention
[!] There may be different output formats available for summarising and
	converting
[?] Need there be a difference?
- It makes sense that a summary would look different. It could leave out
	irrelevant tree nodes, for one thing.
[?] Should the summary be a static file, or should the program act as an 
	interactive viewer?
- It would be nice to have the option of either producing a static 
	report or viewing the results interactively.
- A complex decision tree can be hard to explore without folding, etc.
[?] But what could be displayed interactively that couldn't be shown in
	a static report?

[*] User is never going to want to run the file and output a summary. 
	Output from a run is always going to be a dectree file which can
	then be processed separately
- And the only input format is dectree, of course.
[!] What's the point of outputting the AST as json if it can't be read
	in again?
- I should have different input formats.
- Regardless, the summary is going to be a pretty format rather than 
	a machine-readable one.
[?] Or is it? I could have a JSON or XML summary format. 
- It would then be sensible for the program to be able to read this 
	summary, too.
[?] And do what with it? The program is for summarising a completed
	dectree file - surely reading it in again is out of scope.

		INPUT						PROCESS						OUTPUT
		new	done	summ			quiz	review				new	done	summ
dt		*	*				term	*		*			dt		*	*		*!	
json	*	*		*		gui		*		*			json	*	*		*
xml		*	*		*		http	*		*			xml		*	*		*
														html	*	*		*
														mkdn	*	*		*
														odt		*	*		*
														
[*] Crazy idea, but the interactive summary could itself be a decision tree.
- Would only work for the terminal version - otherwise I'd be forced into a 
	clumsy terminal-like interface for the gui version
- Ok, but decision tree could be a summary output, that's all I'm saying
   
 .-------------------.   .---------------------.
 |                   v   |                     |     Functions:
 |        .-------> CONVERT --------.          |       * Convert format of new/done/summary
 |        |          ^   |          |          |       * Run new/done, producing done
 |    .---(----------'   '----------(----.     |       * Browse done
 |    |   |                         |    v     |       * Summarise done, producing summary
 |  NEW --(-------> QUIZ            |   NEW    |
 |        |  edit    ^ |            |          |
 |    .---(----------' '------------(----.     |
 |    |   |                         |    v     |
 '- DONE -(-------> REVIEW ------.  |   DONE <-'
      |   |                      |  |
      '---(----------.           |  |
          |          v           |  |
    SUMM -'         SUMM         |  '-> SUMM
                     |           |       ^
                     '-----------(-------'
                                 |
                                 '----> NILL
                                 
[?] What information would be stored in the summary format, then, that 
	wouldn't be stored in the dectree AST?
- I guess the summary would describe the user's path?
- One idea for a summary format was to display the user's path as a 
	dialogue, e.g:
	
<dtree>	How are you doing today?
<user>	Pretty good
<dtree>	That's great to hear. What's your favourite colour?
<user>	Black.
<dtree>	How dark. Cats or dogs?
<user>	Cats.
<dtree>	Meow! Do you prefer cake or burgers?
<user>	Cake.
<dtree>	Sweet tooth, eh? Well, thank for your responses.

- But this is a pretty specific use case, I suppose.
[*] For now, could simply use the dectree format for summary output.
[*] Could also forgo the interactive review mode for the time being
- So we're left with 2 operations: running and converting.
- These can be covered by simply having an option for choosing how to
	run the file (terminal/gui/none) and another for the output format
	(dectree/json/xml/html/markdown/odt)
- Oh - I'll also need an input format option too, if I'm to allow
	reading of the AST from json/xml in addition to dt.

[!] Currently validation is done in Document.parse, but if I'm accepting
	different input formats, these will need the same validation logic
	applied to them too.
- Need to separate parsing and validating. Parsing and decoding json
	both result in an AST, which must then be validated.
- They're sort of the same thing, though. A json structure would still 
	have to be validated, of a sort, to ensure the structure is correct
[*] Stuff that is format-agnostic should be re-used, i.e. the stuff I
	already consider to be validation.

+-------------------------------------+
| foobar.dt                       [X] |
+-------------------------------------+
|                                     |
|  Welcome to my amazing qustionaire! |
|  Please fill in all the questions   |
|  and send back the output file.     |
|                                     |
|                                     |
|                                     |
|                                     |
| +--------+               +--------+ |
| |//Prev//|               |  Next  | |
| +--------+               +--------+ |
+-------------------------------------+

+-------------------------------------+
| foobar.dt                       [X] |
+-------------------------------------+
|                                     |
|      ( ) Cheesecake                 |
|      ( ) Trifle                     |
|      (O) Victoria Sponge            |
|      ( ) Jam Donuts                 |
|                                     |
|                                     |
|                                     |
| +--------+               +--------+ |
| |  Prev  |               |  Next  | |
| +--------+               +--------+ |
+-------------------------------------+

[?] Should text blocks and choice blocks always be displayed
	separately?
[!] User might use a text block before a choice to describe
    what the choice is. (e.g. ask a question). If this text
    block isn't displayed with the choice, the recipient
    is left guessing
- Could always show the prior text block, but this assumes 
  that a) it's related to the choice at all and b) that 
  other blocks aren't related too
- Text blocks can't hold multiple paragraphs because blank
  text lines aren't allowed
  
:: Test test test test test test test 
:  test test test test test test test 
:  test test test test test test test 
:                                     <-- not allowed
:  test test test test test test test 
:  test test test test test test test 

[*] Gui runner is going to have to show the previous block, greyed out.
	Similar to the dialog in a game has a kind of scrollback.
[?] Does it need to have a vertical layout rather than a horizontal 
	wizard-like thing, then?
- No, but it would look better

+-------------------------------------+
| foobar.dt                       [X] |
+------------------+------------------+
|/W/l/o/e/t/ /y/ / |                  |
| /m/z/n/ / / / / /| ( ) Cheesecake   |
|/q/e/t/o/a/r/!/ / | ( ) Trifle       |
| /l/a/e/f/l/ /n/ /| (O) Victoria     |
|/t/e/q/e/t/o/s/ / |     Sponge       |
| /n/ /e/d/b/c/ / /| ( ) Jam Donuts   |
|/t/e/o/t/u/ /i/e/ |                  |
+------------------+------------------+
| +---------+             +---------+ |
| | << Prev |             | Next >> | |
| +---------+             +---------+ |
+-------------------------------------+

+-------------------------------------+
| foobar.dt                       [X] |
+------------------+------------------+
|/ / / / / / / / / | Next question:   |
| / / /h/e/e/a/e/ /| what animal is   |
|/(/)/T/i/l/ / / / | your bestest     |
| /O/ /i/t/r/a/ / /| favourite?       |     /
|/ / /S/o/g/ / / / |                  |   \/
| / / /a/ /o/u/s/ /|                  |
|/ / / / / / / / / |                  |
+------------------+------------------+
| +---------+             +---------+ |
| | << Prev |             | Next >> | |
| +---------+             +---------+ |
+-------------------------------------+

+-------------------------------------+
| foobar.dt                       [X] |
+-------------------------------------+
|/W/l/o/e/t/ /y/a/a/i/g/q/e/t/o/a/r/!/|
| /l/a/e/f/l/ /n/t/e/q/e/t/o/s/a/d/ / |
|/s/n/ /a/k/t/e/o/t/u/ /i/e/ / / / / /|     
+-------------------------------------+        
| ( ) Cheesecake      ( ) Jam Donuts  |
| ( ) Trifle                          |
| ( ) Victoria Sponge                 |
+-------------------------------------+
| +---------+             +---------+ |
| | << Prev |             | Next >> | |
| +---------+             +---------+ |
+-------------------------------------+

+-------------------------------------+
| foobar.dt                       [X] |
+-------------------------------------+
|              [ ^ Prev ]             |
+-------------------------------------+
|/W/l/o/e/t/ /y/a/a/i/g/q/e/t/o/a/r/!/|
| /l/a/e/f/l/ /n/t/e/q/e/t/o/s/a/d/ / |
|/s/n/ /a/k/t/e/o/t/u/ /i/e/ / / / / /|     
+-------------------------------------+        
| ( ) Cheesecake      ( ) Jam Donuts  |
| ( ) Trifle                          |
| ( ) Victoria Sponge                 |
+-------------------------------------+
|              [ v Next ]             |
+-------------------------------------+

+-------------------------------------+
| foobar.dt                       [X] |
+---------------------------------+---+
|/W/l/o/e/t/ /y/a/a/i/g/q/e/t/o/a/|   |
| /l/a/e/f/l/ /n/t/e/q/e/t/o/s/a/d|+-+|
|/s/n/ /a/k/t/e/o/t/u/ /i/e/ / / /||^||     
|                                 ||^||
|                                 |+-+|
+---------------------------------+   |        
| ( ) Cheesecake      ( ) Jam Donu|+-+|
| ( ) Trifle                      ||v||
| ( ) Victoria Sponge             ||v||
|                                 |+-+|
|                                 |   |
+---------------------------------+---+

+-------------------------------------+
| foobar.dt                       [X] |
+-------------------------------------+
|/W/l/o/e/t/ /y/a/a/i/g/q/e/t/o/ +---+|
| /l/a/e/f/l/ /n/t/e/q/e/t/o/s/a | ^ ||
|/s/n/ /a/k/t/e/o/t/u/ /i/e/ / / +---+|     
|                                     |
|                                     |
+-------------------------------------+        
| ( ) Cheesecake                      |
| ( ) Trifle                          |
| ( ) Victoria Sponge            +---+|
| ( ) Jam Donuts                 | v ||
|                                +---+|
+-------------------------------------+

+-------------------------------------+
| foobar.dt                       [X] |
+---+---------------------------------+
| ^ | /W/l/o/e/t/ /y/a/a/i/g/q/e/t/o/ |
| ^ |  /l/a/e/f/l/ /n/t/e/q/e/t/o/s/a |
+---+ /s/n/ /a/k/t/e/o/t/u/ /i/e/ / / |     
| v |                                 |
| v |                                 |
+---+---------------------------------+        
|     ( ) Cheesecake                  |
|     ( ) Trifle                      |
|     ( ) Victoria Sponge             |
|     ( ) Jam Donuts                  |
|                                     |
+-------------------------------------+

+-------------------------------------+
| foobar.dt - Kittens             [X] |
+-------------------------------------+
|/W/l/o/e/t/ /y/a/a/i/g/q/e/t/o/a/r/!/|
| /l/a/e/f/l/ /n/t/e/q/e/t/o/s/a/d/ / |
|/s/n/ /a/k/t/e/o/t/u/ /i/e/ / / / / /|     
+-------------------------------------+        
| ( ) Cheesecake      ( ) Jam Donuts  |
| ( ) Trifle                          |
| ( ) Victoria Sponge                 |
+-------------------------------------+
| +---------+             +---------+ |
| | ^^ Prev |             | Next vv | |
| +---------+             +---------+ |
+-------------------------------------+

+-------------------------------------+
| foobar.dt - Kittens             [X] |
+-------------------------------------+
|/W/l/o/e/t/ /y/a/a/i/g/q/e/t/o/a/r/!/|
| /l/a/e/f/l/ /n/t/e/q/e/t/o/s/a/d/ / |
|/s/n/ /a/k/t/e/o/t/u/ /i/e/ / / / / /|     
+-------------------------------------+        
| ( ) Cheesecake      ( ) Jam Donuts  |
| ( ) Trifle                          |
| ( ) Victoria Sponge                 |
+-------------------------------------+
|           +-----+ +-----+           |
|           |  ^  | |  v  |           |
|           +-----+ +-----+           |
+-------------------------------------+

+--------------------------------------------------------+
| foobar.dt                                          [X] | 
+------------------+------------------+------------------+
|/W/l/o/e/t/ /y/ / |                  |                  |
| /m/z/n/ / / / / /| ( ) Cheesecake   |                  |
|/q/e/t/o/a/r/!/ / | ( ) Trifle       |   +----------+   |
| /l/a/e/f/l/ /n/ /| (O) Victoria     |   | << Prev  |   |
|/t/e/q/e/t/o/s/ / |     Sponge       |   +----------+   |
| /n/ /e/d/b/c/ / /| ( ) Jam Donuts   |                  |
|/t/e/o/t/u/ /i/e/ |                  |   +----------+   |
|                  |                  |   | Next >>  |   |
|                  |                  |   +----------+   |
|                  |                  |                  |
|                  |                  |                  |
+------------------+------------------+------------------+

+---------------+
|+---++---++---+|
|| N || S || E ||
|+---++---++---+|
+---------------+

         content size
          <--------->
   ^  +-----------------+  ^ variable
 f |  |                 |  | 
 i |  +---+---------+---+  v  ^
 x |  |   |I am a   |   |     | content size
 e |  |   |box yeah!|   |     |
 d |  +---+---------+---+  ^  v
   |  |                 |  | 
   v  +-----------------+  v variable
      <--->         <--->
     variable      variable


[!] Need a way to temporarily insert the response text into the graph
[*] Store "prev" ref differently. "next" refs are per step to make a directional
	graph. "prev" is simply a single reference to the last step user was at
[!] That won't work because we won't be able to traverse the path back to
	the start
[*] Ok so store a prev ref with each step, which is simply set to the previous
	step at runtime
- call it "undo" to distinguish
- nah.
